# 📦 BuildiFy - WMS 시스템 (1차 프로젝트)

## 프로젝트 개요
**BuildiFy**는 Java CLI 환경에서 구현된 창고 관리 시스템(Warehouse Management System, WMS)입니다.  
조립형 PC 부품의 입출고 및 재고 관리를 위한 시스템으로, MySQL 데이터베이스를 활용하여 제품의 입고, 출고, 재고 현황을 효율적으로 관리할 수 있습니다.

---

## 🖥 주요 사용 기술
- **Language**: Java
- **Database**: MySQL
- **Framework/Library**: JDBC
- **Version Control**: Git

---

## 📂 프로젝트 구조


```
BuildiFy
├── common
├── config
├── controller
├── domain
│   ├── inbound
│   ├── outbound
│   ├── inventory
│   └── accountManagement
│       ├── User
│       └── Admin
├── dto
├── exception
├── MySql
└── resources
```


- `common`: 공통 유틸 및 상수 정의
- `config`: 환경 설정 파일
- `controller`: 사용자 요청 처리
- `domain`: 도메인별 비즈니스 로직 관리
   - `inbound`: 입고 관리
   - `outbound`: 출고 관리
   - `inventory`: 재고 관리
   - `accountManagement`: 계정 관리 (User, Admin)
- `dto`: 데이터 전달 객체 정의
- `exception`: 예외 처리 모듈
- `MySql`: DB 연결 및 쿼리 처리
- `resources`: 리소스 파일 관리

---

## 🔧 ERD 설계 의도 및 핵심 포인트

### 1. 🧑‍💼 user (고객)
- **입출고 요청의 주체**가 되는 핵심 테이블
- `user_status`로 **회원가입 승인 여부** 판단 → 승인된 고객만 입출고 가능
- 사업자번호, 창고 사용량 등 **B2B 물류 시나리오 반영**

### 2. 📦 product (상품)
- 입고 요청 전 **반드시 사전 등록** 필요
- `prod_id`는 브랜드+연도+일련번호 조합으로 중복 방지
- 크기, 카테고리 등 다양한 필터링 지원

### 3. 📥 inbound (입고)
- **입고 요청과 승인 절차**를 관리
- 입고 지연 확인을 위한 `req_inbound_day`, `last_inbound_day` 존재
- `ware_id`로 창고 지정 가능

💡 *입고 흐름:* 고객이 상품 등록 → 입고 요청 → 관리자 승인 → 재고 반영

### 4. 🗃 inventory (재고)
- 입고 완료 시 재고로 반영
- 고객, 상품, 창고 기준으로 **재고 현황 파악**
- `last_inbound_day`, `last_outbound_day`로 **회전율 분석** 가능

### 5. 📤 outbound (출고)
- 재고 기반으로 출고 요청
- `status`로 승인/보류 흐름 관리
- 출고 시 **inventory 연동 → 수량 자동 차감**

### 6. 👨‍💼 admin (관리자)
- 관리자 권한에 따라 **고객 승인, 입출고 처리**
- 로그인용 ID/PW 정보 포함

### 7. 🏭 warehouse (창고)
- 창고별 ID와 **수용 가능 용량(capacity)** 관리
- 상품 배치 가능 여부 판단 기준 제공

### 8. 🗺 warehouse_area (창고 구역)
- 창고 세부 위치 및 이름 관리
- 향후 **자동 배치 알고리즘 확장성** 고려


## 🔨 내가 담당하고 구현한 기능

### 1. 📝 사용자 회원가입
- 사용자가 입력한 비밀번호에 대해 **`salt` + `SHA-256` 해시 알고리즘**을 적용하여 암호화
- 암호화된 비밀번호를 DB에 저장함으로써 **데이터 유출 시 보안 위험 최소화**
- 암호화 처리 후, 사용자 정보를 `user` 테이블에 등록

### 2. 🔐 사용자 로그인
- 사용자가 입력한 비밀번호에 대해 동일하게 `salt + SHA-256` 해시 적용
- DB에 저장된 암호화 값과 대조하여 **로그인 성공 여부 판단**
- 평문 비밀번호를 저장하지 않고 비교하는 방식으로 **보안 강화**

### 3. ✏️ 사용자 정보 변경
- 로그인된 사용자는 자신의 정보(연락처, 이메일 등)를 수정 가능
- 변경된 데이터는 `UPDATE` 쿼리를 통해 `user` 테이블에 반영

### 4. 📦 사용자 상품 등록
- 고객은 입고 요청에 앞서 **상품을 사전에 등록**
- `product` 테이블에 이름, 가격, 사이즈, 카테고리 등의 정보를 입력
- 상품 ID(`prod_id`)는 중복 방지를 위해 **브랜드 + 생산년도 + 일련번호** 조합 방식 사용

### 5. 🔍 등록된 상품 조회
- 사용자가 등록한 상품 리스트를 조회 가능
- `product` 테이블에서 조건에 맞는 상품 목록을 불러오도록 구현
- 검색, 정렬 등 확장 고려하여 구조 설계

### 6. 🚚 출고 요청 기능
- 사용자가 보유한 상품을 출고 요청할 수 있도록 기능 구현
- 새로운 DTO인 `ReqOutboundDto`를 정의해 **출고 요청 전용 데이터 구조 분리**
- **`product` 테이블과 `inventory` 테이블을 조인**하여,
  - 사용자가 보유한 재고 목록 중에서
  - **상품 정보(이름, 사이즈, 브랜드 등)** 도 함께 표시되도록 함
- 이 조인을 통해 **“내가 가진 재고 + 상품 상세 정보”**를 한눈에 확인하고 출고 요청 가능

# 프로젝트 실행 가이드

## 실행 방법
- `src` 폴더의 **`Main` 클래스**에서 실행합니다.
- **MySQL Connector JAR** 및 **Lombok 라이브러리**를 미리 세팅해야 합니다.

## 계정 정보
### ✅ 관리자 (ADMIN)
- ID : `admin01`
- 비밀번호 : `admin123`

### ✅ 사용자 (USER)
- ID : `SalesTeam1`
- 비밀번호 : `!dlehdgnl3546`

## 데이터베이스 세팅 방법
기본적인 제품 등록과 / 입고요청은 sql문에 구성되어있습니다.
MySQL 데이터베이스를 아래의 방법으로 설정하세요.


### 1️⃣ 터미널에서 실행
```sh
mysql -u [사용자명] -p [비밀번호] < src/MySql/wmsdb.sql
```




## 🛠 주요 기능

### 사용자(입점 회사)
- 회원가입 신청 → **관리자의 승인 후** 가입 완료
- 로그인
- **입고 요청** 등록
- **출고 요청** 등록
- 자사 **재고 조회**
- **회원 정보 조회 및 수정**

### 관리자
- 사용자 **가입 승인 및 관리**
- **입고 요청 처리 및 입고 관리**
- **출고 요청 처리 및 출고 관리**
- 전체 **재고 관리**
- **관리자 정보 조회 및 수정**

---

## 📦 제품 카테고리 (1차 프로젝트 기준)
- CPU
- 메모리
- RAM
- 그래픽카드
- 모니터
- 마우스
- 키보드

> 📌 **Note**: 2차 프로젝트에서 웹 환경으로 확장 시, 카테고리 추가 및 기능 개선 예정

---

## 🚧 개발 예정 (2차 프로젝트)

- 기존 순수 Java 기반 프로젝트를 **Spring Boot 프레임워크**로 전환  
- 데이터 접근 계층에 **MyBatis**를 적용하여 생산성과 유지보수성 향상  
- 웹 기반 UI 및 기능 확장  
- 제품 카테고리 세분화 및 추가  
- 사용자 경험 향상을 위한 UI 개선


---

## 👥 팀원
- **김선민**
- **김성준**
- **이동휘**
- **신민혁**

---

# 📝 개발 컨벤션


## Git Rule
깃 허브 연동 순서
1. git add . (본인이 작성 혹은 수정한 사항을 commit 대기 상태로 등록)
2. git commit -m “#이슈번호 커밋타입: 커밋메시지”
3. git pull origin main (본인 프로젝트를 현재 깃허브의 프로젝트 코드와 동기화)
4. git push origin 본인브랜치명
5. pull request  (조원 모두 참여 및 확인)

## Commit Message 규칙
1. 제목과 본문을 빈 행으로 구분한다.
2. 제목은 50글자 이내로 제한한다.
3. 제목의 첫 글자는 대문자로 작성한다.
4. 제목 끝에는 마침표를 넣지 않는다.
5. 제목은 명령문으로 사용하며 과거형을 사용하지 않는다.
6. 본문의 각 행은 72글자 내로 제한한다.
7. 어떻게 보다는 무엇과 왜를 설명한다.



## ✅ Commit Message 구조

> `Header`, `Body`, `Footer`는 **빈 줄**로 구분합니다.

타입(스코프): 제목  // Header (헤더)

본문  // Body (바디)

바닥글  // Footer (푸터)

---

## 📌 Commit 타입(Type)

| 타입       | 설명                                                   |
|------------|--------------------------------------------------------|
| `feat`     | 새로운 기능 추가                                       |
| `fix`      | 버그 수정                                              |
| `build`    | 빌드 관련 파일 수정 / 모듈 설치 또는 삭제              |
| `chore`    | 기타 자잘한 작업 (ex. 패키지 정리, 주석 등)            |
| `ci`       | CI 관련 설정 변경                                      |
| `docs`     | 문서 관련 변경                                         |
| `style`    | 코드 포맷, 스타일 변경 (기능에 영향 없음)              |
| `refactor` | 코드 리팩토링 (동작 변경 없이 구조 개선)               |
| `test`     | 테스트 코드 추가 및 수정                              |
| `perf`     | 성능 개선                                              |

---

## 🧾 Commit 작성 규칙

- `Header`, `Body`, `Footer`는 반드시 **빈 줄**로 구분합니다.
- `Header`는 **명령문** 형태로 작성하며, 50자 이내로 간결하게 씁니다.
- `Header`는 **대문자로 시작**, **마침표는 생략**합니다.
- `Body`는 선택 사항이며, **무엇을, 왜 했는지** 설명합니다.
  - 어떻게 했는지는 생략 가능
  - 각 줄은 72자 이내로 작성 권장
- `Footer`에는 관련 이슈 번호를 작성합니다. (예: `resolves: #123`)
  - 생략 가능

---

## ✅ 예시

git commit -m "feat: 식당관리화면에서 상단 탭 클릭시 화면 전환(spa)

식당관리자가 볼 수 있는 식당관리 화면에서,
상단에 식당관리, 전체예약현황, 리뷰전체보기 탭을 추가함.
탭 클릭 시 해당 화면으로 전환되도록 기능 구현.

resolves: #7"


## ✅ 컨벤션 정의

### 1. 변수 및 함수 Naming Convention

1.1 변수, 함수, 인스턴스  
- `camelCase` 사용  
  예: `userList`, `getUserData()`

1.2 함수명 작성  
- `동사 + 명사` 형태  
  예: `getUserInformation()`

1.3 클래스 및 생성자  
- `PascalCase` 사용 (= Upper CamelCase)  
  예: `UserService`, `OrderManager`

1.4 글자 길이 제한  
- 변수명은 **20자 이내**로 작성  
- 4단어 이상이거나, 불가피하게 20자 초과 시 팀원과 상의

1.5 플래그(Boolean) 변수  
- `조동사 + 의미 있는 단어` 조합 사용  
  예: `isAvailable`, `hasPermission`

1.6 약어(축약어) 사용 금지  
- 축약어는 되도록 사용하지 않음  
  예:  
  - `let idx; // bad`  
  - `let index; // good`

1.7 들여쓰기(tab) 깊이 제한  
- 최대 **4 depth**  
- 초과 시 함수로 분리  
  예:
  ```java
  function example() {
      if (condition) {
          array.reduce((prev, curr) => {
              // 최대 4 depth 이하 유지
          });
      }
  }
  ```

1.8 주석 작성 규칙  
- 한 줄: `//`  
- 여러 줄: `/** ... */`

1.9 함수 파라미터 개수 제한  
- **최대 3개까지** 허용  
  예:
  ```js
  function test(a, b, c) {
      console.log(a, b, c); // Good
  }
  ```

1.10 비동기 함수  
- `async/await` 사용을 권장

---

## ✅ DB 네이밍 규칙

### 2.1 데이터베이스 이름 (스키마)
- 영어 **소문자**만 사용  
- 길이는 **8자 이내**로 제한  
  예: `wmsdb`, `orderdb`

### 2.2 테이블 이름
- **단수형** 사용 (예: `user`, `product`)  
- 형식: `대분류_의미있는이름`  
- 규칙:
  - 영어 소문자 사용
  - 최대 3단어까지
  - 단어당 최대 8자
  - 전체 테이블명은 26자 이내

  예:  
  - `user_info`  
  - `product_stock`  

### 2.3 컬럼 이름
- **snake_case** 사용  
- `의미 있는 컬럼명 + 접미사` 형태  
- 접미사는 데이터 타입이 아닌 **성격**을 나타냄  

  예:  
  - `user_id`
  - `created_at`
  - `is_deleted`

---

# 프로젝트 회고록

## 1. 느낀점

Java와 MySQL을 이용해서 창고 관리 시스템을 만들면서,  
실제 물류 서비스들이 어떠한 고민과 거듭된 설계를 통해  
사용자들이 편리하게 사용할 수 있는지를 다시금 느끼게 되었다.

이번 프로젝트는 단순히 기능을 구현하는 것을 넘어,  
**앞으로 개발자로서 어떻게 유저들에게 편리함을 전달할 것인가**에 대해  
깊이 고민해보는 시간이었다.

---

## 2. 개선해야 할 점

- **클린 코드의 중요성 재확인**  
  기간 내에 설계된 패턴을 사용하고 구현에 집중하다 보니,  
  더 간결하고 가독성 있는 코드를 작성하지 못한 점이 아쉬웠다.  
  다음 프로젝트에서는 **클린 코드와 리팩토링**에 대한 기준을  
  좀 더 명확히 하고 실천하려는 노력이 필요하다.

- **사용자 경험(UX)에 대한 고민 부족**  
  UI 구현 면에서는 아쉬움이 남는다.  
  기능은 동작하지만, 사용자 입장에서 **더 만족스러운 경험을 주기 위한 세심한 UI/UX 설계**가 부족했다.  
  앞으로는 사용자 관점에서 **더 직관적이고 편리한 인터페이스**를 제공하기 위한 노력이 필요하다고 느꼈다.

---

## 3. 배운 점

- **데이터 모델링의 중요성**  
  단순히 테이블을 만드는 것을 넘어서,  
  실제 서비스 흐름을 반영한 **정확하고 유연한 데이터 구조를 설계하는 일**이  
  얼마나 많은 고민과 시간이 필요한 작업인지를 몸소 느꼈다.

- **실제 서비스들이 가진 설계의 깊이**  
  우리가 일상적으로 사용하는 택배, 쿠팡, 쓱과 같은 물류 서비스들이  
  단순한 UI 너머에 **얼마나 복잡하고 정교한 시스템 설계**가 있는지를 체감했다.  
  이번 프로젝트를 통해 그런 서비스들의 구조와 고민을 **직접 경험하며 간접적으로 배울 수 있었다.**

---

## 4. 다음에 활용할 점

- **MyBatis / JPA 적용**  
  이번 프로젝트에서는 JDBC 기반으로 직접 쿼리를 다뤘지만,  
  다음에는 `MyBatis`나 `JPA`를 사용해 **객체 중심의 데이터 처리**를 경험해보고자 한다.  
  보다 효율적이고 유지보수하기 쉬운 코드 작성을 위해 꼭 도전해보고 싶은 부분이다.

- **Spring / Spring Boot 도입**  
  많은 기업들이 공통적으로 사용하는 **Spring 기반의 백엔드 프레임워크**를  
  실제 프로젝트에 적용해보는 것이 다음 목표다.  
  구조화된 개발 환경과 다양한 생태계를 활용해  
  더 나은 설계와 생산성을 확보할 수 있을 것으로 기대된다.

- **Git 커밋 컨벤션 준수**  
  팀 협업 과정에서 커밋 메시지의 일관성이 중요하다는 점을 느꼈다.  
  **누가 봐도 작업 내역이 명확하게 드러나는 커밋 작성 습관**을 다음 프로젝트에서는 더욱 철저히 지켜야겠다.

---

## 5. 협업 중 겪은 문제와 해결 경험

### 💡 로컬 개발 환경 차이로 인한 통합 테스트 이슈

4명이 각자의 로컬 MySQL 환경에서 개발을 진행하다 보니,  
누군가의 DB에는 존재하는 프로시저가 다른 사람의 환경에는 없는 문제가 자주 발생했다.  
그때마다 각자 수동으로 프로시저를 등록해야 했고,  
이로 인해 통합 테스트 과정에서 오류가 발생하거나 불필요한 디버깅 시간이 소요되었다.

이 문제를 해결하기 위해 `Railway`라는 클라우드 기반 데이터베이스 서비스를 도입했다.  
공통 원격 DB를 구성한 뒤, 모든 팀원이 동일한 인스턴스를 공유하도록 설정했고,  
필요한 프로시저들도 한 번만 등록하면 모두가 사용할 수 있도록 구성했다.

그 결과, 환경 차이로 인한 테스트 오류가 거의 사라졌고,  
모든 작업자가 동일한 데이터를 기반으로 안정적인 개발을 이어갈 수 있었다.  
또한, **협업 중 발생할 수 있는 사소한 혼선을 미연에 방지하는 것이 얼마나 중요한지를 체감**할 수 있었다.

## 6. 요약

이론으로만 알던 내용을 실제 데이터 모델링, ERD 설계, 자바 프로젝트, MySQL 구현까지  
직접 해보며 **동료들과 밤낮없이 몰입한 끝에 조금은 ‘제대로 된’ 결과물을 만들었다는 성취감과 자부심**을 느꼈다.

특히 Java 프로젝트에서는 단순한 MVC 구조를 넘어서,  
기능이 많아지며 복잡해진 모델과 컨트롤러를 **상위 컨트롤러에서 통합 관리하는 구조로 확장**해보는 시도를 했다.  
단순 구현에 그치지 않고, 구조적 설계와 유지보수성까지 고민하며  
**조금 더 실무에 가까운 백엔드 개발 흐름을 직접 체감**할 수 있었던 뜻깊은 경험이었다





